<!DOCTYPE html>
<html>
  <head>
    <meta name='author' content='Albert Wu'>
    <meta name='description' content='CS 61A TA website for Albert Wu'>
    <title>CS 61A: Interpreters: exam</title>
    <link rel='stylesheet' type='text/css' href='/cs61a/public/style.css'>
    <link rel='stylesheet' type='text/css' href='/cs61a/public/prettify/prettify.css'>
    <link href='http://fonts.googleapis.com/css?family=Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono' rel='stylesheet' type='text/css'>
    <link rel='stylesheet' media='print' type='text/css' href='/cs61a/public/print.css'>
    <script src='/cs61a/public/prettify/prettify.js'></script>
      <link rel='stylesheet' type='text/css' href='/cs61a/review/public/style.css'>
    

    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-39937584-1', 'albertwu.org');
      ga('send', 'pageview');
    </script>

  </head>
  <body onload='prettyPrint()'>
    <div id='container'>
      <div id='logo'>
        <h1>Interpreters: exam</h1>
      </div>

      <div id='nav-bar'>
        <div id='accordion'>
          <h3>Navigation</h3>
<div>
  <ul>
    <li><a href='/cs61a/index.html'>Home</a></li>
    <li><a href='/cs61a/review/index.html'>All Topics</a></li>
    <li><a href='/cs61a/review/mt1.html'>Midterm
      1</a></li>
    <li><a href='/cs61a/review/mt2.html'>Midterm
      2</a></li>
    <li><a href='/cs61a/review/final.html'>Final</a></li>
  </ul>
</div>
<h3>Conceptual</h3>
<div><ul>
  <li><a href="#conceptual1">Q1</a></li>
  <li><a href="#conceptual2">Q2</a></li>
</ul></div>
<h3>Code Writing</h3>
<div><ul>
  <li><a href="#code1">Q1</a></li>
</ul></div>
        </div>
        <div id='nav-bar-fixed'>
          
        </div>
        <a href='http://www-inst.eecs.berkeley.edu/~cs61a/fa13/'>CS
          61A course page</a>
      </div>

      <div id='content'>
          <div id='reference'>
    <h2>References</h2>

    <p>You can review interpreters in the following places</p>
    <ul>
  <li><a href="http://www-inst.eecs.berkeley.edu/~cs61a/fa13/slides/25-Calculator_1pps.pdf">Lecture: Calculator</a></li>
  <li><a href="http://www-inst.eecs.berkeley.edu/~cs61a/fa13/slides/26-Interpreters_1pps.pdf">Lecture: Interpreters</a></li>
  <li><a href="http://www-inst.eecs.berkeley.edu/~cs61a/fa13/lab/lab08/lab08.php">Lab 8</a></li>
  <li><a href="http://www-inst.eecs.berkeley.edu/~cs61a/fa13/disc/discussion10.pdf">Discussion 10</a></li>
</ul>
  </div>

  

  <div id='contents'>
    <h2>Contents</h2>
    <ol>
  <li><a href="#conceptual">Conceptual</a></li>
  <li><a href="#code">Code Writing</a></li>
</ol>
  </div>

  <p>Each question has a "Toggle Solution" button -- click it to
  reveal that question's solution.</p>

  <noscript>You need to <b>enable JavaScript</b> to view the
    solutions.</noscript>

  <h2 id="conceptual" class="subtopic anchor">Conceptual</h2>
<h3 id="conceptual1" class="question anchor">Q1</h3>
<p>Given the following Scheme expressions, what
        would <tt>scheme_read</tt> from Project 4 return? If the parser
        would raise an error, write ERROR. The first one is done for
        you.</p>
<pre class="prettyprint">
scm&gt; (+ 2 3)
Pair('+', Pair(2, Pair(3, nil)))
scm&gt; '(1 2 3)
______
scm&gt; (1 . 2)
______
scm&gt; 3
______
scm&gt; (1 . (3 2))
______
scm&gt; ('hi . 3 4)
______</pre>
<button id='0' class='toggleButton'>Toggle Solution<noscript> (enable JavaScript)</noscript></button><div class="solution 0"><p><b>Answer: </b><pre class="prettyprint">
scm> '(1 2 3)
Pair('quote', Pair(Pair(1, Pair(2, Pair(3, nil))), nil))
scm> (1 . 2)
Pair(1, 2)
scm> 3
3
scm> (1 . (3 2))
Pair(1, Pair(3, Pair(2, nil)))
scm> ('hi . 3 4)
ERROR</pre>
</p>
</div>
<h3 id="conceptual2" class="question anchor">Q2</h3>
<p>Given each of the following Pair objects,
        determine how many times <tt>scheme_eval</tt> and
        <tt>scheme_apply</tt> are called (not <tt>calc_eval</tt> and
        <tt>calc_apply</tt>!). Be sure to include the first
        <tt>scheme_eval</tt>. The first one has been done for you.</p>

        <p><b>Note</b>: assume that the following <tt>double</tt>
        function has been defined:<pre class="prettyprint">
(define (double x) (+ x x))</pre>
</p>
<pre class="prettyprint">
(+ 2 3)
; eval  4   (1 for whole expression, 1 for each element in list)
; apply 1   ('+' is primitive)

3
; eval  ________
; apply ________

(+ 3 (+ 5 2))
; eval  ________
; apply ________

(double 4)
; eval  ________
; apply ________

(double (double 4))
; eval  ________
; apply ________
</pre>
<button id='1' class='toggleButton'>Toggle Solution<noscript> (enable JavaScript)</noscript></button><div class="solution 1"><p><b>Answer: </b><pre class="prettyprint">
3
; eval  <b>1</b>
; apply <b>0</b>

(+ 3 (+ 5 2))
; eval  <b>7</b>
; apply <b>2</b>

(double 4)
; eval  <b>7</b>
; apply <b>2</b>

(double (double 4))
; eval  <b>13</b>
; apply <b>4</b></pre>
</p>
</div>

<h2 id="code" class="subtopic anchor">Code Writing</h2>
<h3 id="code1" class="question anchor">Q1</h3>
<p>Write a function <tt>is_pyramid</tt> that
        takes in a list of tokens, and checks if the list of tokens
        forms a pyramid. A <i>pyramid</i> is a list that is symmetric
        in <i>shape</i> (not necessarily the contents), and each list
        can only have one nested list at its level. The following are
        examples of valid pyramids:
        <pre class="prettyprint">
(3 4 (5 (1) 3) 2 3)
(1 2 3 4)           # no nested lists is okay
(1 (2 () 3) 4)      # empty lists are okay
(1 (2) 3) )()       # junk, )(), after a valid pyramid is okay
(1 () 2) s d fs     # junk after a valid pyramid is okay</pre>
The following are examples of invalid pyramids:<pre class="prettyprint">
(2 (3) 4 5)     # too many elements on the right side
((3) (4))       # too many nested lists on the first level
(3 4            # missing closing parenthesis</pre>
</p>
<pre class="prettyprint">
def is_pyramid(tokens):
    """Returns true if the list of tokens begins with a valid
    pyramid. Junk at the end is okay.

    &gt;&gt;&gt; t1 = ['(', 3, '(', 4, ')', 5, ')']  # (3 (4) 5)
    &gt;&gt;&gt; is_pyramid(t1)
    True
    &gt;&gt;&gt; t2 = ['(', '(', '(', ')', ')', ')'] # ((()))
    &gt;&gt;&gt; is_pyramid(t2)
    True
    &gt;&gt;&gt; t3 = ['(', 3, '(', 2, 3, ')', 4, ')', 3, 4] # (3 (2 3) 4) 3 4
    &gt;&gt;&gt; is_pyramid(t3)
    True
    &gt;&gt;&gt; f1 = ['(', 2, '(', 3, ')', 4, 5, ')'] # (2 (3) 4 5)
    &gt;&gt;&gt; is_pyramid(f1)
    False
    &gt;&gt;&gt; f2 = ['(', '(', 3, ')', '(', 4, ')', ')'] # ((3) (4))
    &gt;&gt;&gt; is_pyramid(f2)
    False
    &gt;&gt;&gt; f3 = ['(', 3, 4] # (3 4
    &gt;&gt;&gt; is_pyramid(f3)
    False
    """
    if not tokens or tokens[0] != '(':
        return False
    tokens.pop(0)
    "*** YOUR CODE HERE ***" </pre>
<button id='2' class='toggleButton'>Toggle Solution<noscript> (enable JavaScript)</noscript></button><div class="solution 2"><pre class="prettyprint">
def is_pyramid(tokens):
    if not tokens or tokens[0] != '(':
        return False
    tokens.pop(0)
    count, direction = 0, 1
    while tokens and tokens[0] != ')':
        if direction == -1 and count == 0:
            return False
        elif tokens[0] == '(':
            if direction == -1 or not is_pyramid(tokens):
                return False
            else:
                direction = -1
        else:
            tokens.pop(0)
            count += direction
    if not tokens:
        return False
    else:
        tokens.pop(0)
        return direction == 1 or count == 0</pre>
<p><b>Explanation: </b>The base case that is provided checks that
        the tokens begin with an '('. If it doesn't, then we
        immediately know that it is not a pyramid. We then remove the
        '('.</p>
        <p>First, let's write code that simply goes through each
        element and removes it from the list of tokens. The word
        <i>each</i> indicates that we need some looping structure, so
        we'll use a while look. Our while loop should stop if we reach
        the end of the list of tokens, or if we see a ')':<pre class="prettyprint">
def is_pyramid(tokens):
    if not tokens or tokens[0] != '(':
        return False
    tokens.pop(0)
    while tokens and tokens[0] != ')':
        if tokens[0] == '(':
            # handle case for nested lists
        else:
            # handle case for numbers</pre>

        How do we handle a nested list? Simply make a recursive call;
        if the nested list is not a valid pyramid, the recursive call
        will return False. The recursive call has the additional
        benefit of removing the nested list, including its closing
        parenthesis:<pre class="prettyprint">
...
if tokens[0] == '(':
    if not is_pyramid(tokens):
        return False
...</pre>
How do we handle a number? Simply
        remove it from the list of tokens:<pre class="prettyprint">
...
else:
    tokens.pop(0)
...</pre>
What happens if we break out of
        our while loop? There are two scenarios: 1) if we run out of
        tokens, and 2) if the first token is a ')'. If we run out of
        tokens, we should return False, because that means we never
        saw the corresponding ')'. If the first token is a ')', then
        we successfully closed the list and we can just pop it off and
        return True:
        <pre class="prettyprint">
...
while tokens and tokens[0] != ')':
    ...
if not tokens:
    return False
else:
    tokens.pop(0)
    return True</pre>
At this point, our code
    looks like this:<pre class="prettyprint">
def is_pyramid(tokens):
    if not tokens or tokens[0] != '(':
        return False
    tokens.pop(0)
    while tokens and tokens != ')':
        if tokens[0] == '(':
            if not is_pyramid(tokens):
                return False
        else:
            tokens.pop(0)
    if not tokens:
        return False
    else:
        return True</pre>
This looks
    promising, but it doesn't account for the symmetry of the list.
    Here's the idea. We'll keep track of two variables: 1) a
    <tt>count</tt>, which counts the number of elements before the
    nested list, and then checks that the number of elements after the
    nested list matches; 2) a <tt>direction</tt>, that tells us whether
    we're before the nested list or after it:<pre class="prettyprint">
...
tokens.pop(0)
count, direction = 0, 1
while tokens and tokens[0] != ')':
    ...</pre>
We'll use the convention that,
    when direction is 1, we are incrementing our count, and when
    direction is -1, we are decrementing our count.</p>
    <p>Now, let's go in the while loop. If <tt>tokens[0] == '('</tt>
    (meaning we see a nested list), this tells us that we've reached
    our midpoint, and we should begin decrementing count after this:
    <pre class="prettyprint">
if tokens[0] == '(':
    if not is_pyramid(tokens):
        return False
    else:
        direction = -1</pre>
In addition,
    if our direction is already -1 (meaning we've already seen a nested
    list), and we see another nested list, this breaks our definition
    of a pyramid, so we should return False (e.g. the case
    <tt>((3) (4))</tt>):<pre class="prettyprint">
if tokens[0] == '(':
    if direction == -1 or not is_pyramid(tokens):
        return False
    else:
        direction = -1</pre>
What about the
        case of regular numbers? In addition to removing the token,
        we also need to update our <tt>count</tt>. If direction is 1,
        we should increment; if it is -1 (i.e. we've seen a nested
        list already), we should decrement:<pre class="prettyprint">
else:
    tokens.pop(0)
    count += direction</pre>
We need one
    other case inside the while loop; what happens if we see
    <tt>(3 (4) 5 6)</tt>? There are too many elements on the right
    side! Walk through the code we have right now, and you'll notice
    that when we reach the 6, <tt>count</tt> will be 0, and
    <tt>direction</tt> will be -1. This is the red flag we look for
    to tell us to return False:<pre class="prettyprint">
while tokens and tokens[0] != ')':
    if direction == -1 and count == 0:
        return False
    if tokens[0] == '(':
        ...</pre>
Almost done! At the end,
        we need to update the case where <tt>tokens</tt> is not empty.
        Consider this example: <tt>(3 4 () 3)</tt>. The right side
        contains too few elements. How can we tell? <tt>count</tt> will
        be nonzero! Instead of just returning True, we add the
        additional check on count:<pre class="prettyprint">
if not tokens:
    return False
else:
    return direction == 1 or count == 0</pre>
Overall,
    our code looks like this:<pre class="prettyprint">
def is_pyramid(tokens):
    if not tokens or tokens[0] != '(':
        return False
    tokens.pop(0)
    count, direction = 0, 1
    while tokens and tokens[0] != ')':
        if direction == -1 and count == 0:
            return False
        elif tokens[0] == '(':
            if direction == -1 or not is_pyramid(tokens):
                return False
            else:
                direction = -1
        else:
            tokens.pop(0)
            count += direction
    if not tokens:
        return False
    else:
        tokens.pop(0)
        return direction == 1 or count == 0</pre>
</p>
</div>

  </div>
      </div>
    </div>
  </body>

  <script src='/cs61a/public/jquery-1.10.1.min.js'></script>
  <script src="/cs61a/public/jquery-scrolltofixed-min.js"></script>
  <script src="http://code.jquery.com/ui/1.10.3/jquery-ui.js"></script>
  <script>
    $(document).ready(function() {
      $('#accordion').accordion({
        heightStyle: 'content'
      });
    });
  </script>
    <script src='/cs61a/review/public/nav-bar.js'></script>
  <script src='/cs61a/review/public/toggle.js'></script>
  
</html>
